(define (elaborate e)
  (cond ((symbol? e) e)
        ((self-evaluating? e) (list 'quote e))
        ((string? e)
         (elaborate `(quote ,(map char->integer (string->list e)))))
        (else
         (assert (pair? e) "Bad syntax" e)
         (case (car e)
           ((quote)
            e)
           ((begin)
            (elaborate-seq (cdr e)))
           ((lambda)
            `(lambda ,(cadr e) ,(elaborate-seq (cddr e))))
           ((letrec)
            `(letrec ,(map (lambda (defn)
                             (list (car defn) (elaborate (cadr defn))))
                           (cadr e))
               ,(elaborate-seq (cddr e))))
           ((local)
            (elaborate
             `(letrec ,(map (lambda (defn)
                              ;; (define (caadr . cdadr) . cddr)
                              `(,(caadr defn)
                                (lambda ,(cdadr defn) ,@(cddr defn))))
                           (cadr e))
               ,@(cddr e))))
           ((let)
            (elaborate `((lambda ,(map car (cadr e))
                           ,@(cddr e))
                         ,@(map cadr (cadr e)))))
           ((if)
            (let ((test (cadr e)) (if-true (caddr e)) (if-false (cadddr e)))
              (elaborate `((%true? ,test) (lambda () ,if-true)
                                          (lambda () ,if-false)))))
           ((mcase)
            (elaborate (expand-mcase (gensym) (cadr e) (cddr e))))
           (else
            (map elaborate e))))))

(define (expand-mcase subject subject-exp clauses)

  (define (expand-clause clause else-exp)
    (let ((pattern (car clause))
          (then-exp `(begin . ,(cdr clause)))
          (fail (gensym)))
      `(let ((,fail (lambda () ,else-exp)))
         ,(expand-pattern pattern then-exp `(,fail)))))

  (define (expand-pattern pattern then-exp else-exp)
    (define (test-constant constant)
      `(if (eqv? ,subject ',constant) ,then-exp ,else-exp))
    (cond ((eqv? pattern '_)
           then-exp)
          ((starts-with? 'quote pattern)
           (test-constant (cadr pattern)))
          ((symbol? pattern)
           `(let ((,pattern ,subject)) ,then-exp))
          ((starts-with? ': pattern)
           (let ((name (cadr pattern)) (predicate (caddr pattern)))
             `(if (,predicate ,subject)
                  (let ((,name ,subject)) ,then-exp)
                  ,else-exp)))
          ((pair? pattern)
           `(if (pair? ,subject)
                (mcase (car ,subject)
                  (,(car pattern) (mcase (cdr ,subject)
                                    (,(cdr pattern) ,then-exp)
                                    (_ ,else-exp)))
                  (_ ,else-exp))
                ,else-exp))
          (else
           (test-constant pattern))))

  `(let ((,subject ,subject-exp))
     ,(foldr expand-clause '(%match-error) clauses)))

(define (self-evaluating? x)
  (or (boolean? x)
      (integer? x)))

(define (elaborate-seq es)
  (make-begin (map elaborate es)))

(define (make-begin es)
  (cond ((null? es) ''#f)
        ((null? (cdr es)) (car es))
        (else (make-begin2 (car es)
                           (make-begin (cdr es))))))

(define (make-begin2 e1 e2)
  `((lambda (v thunk) (thunk))
    ,e1
    (lambda () ,e2)))

(define (starts-with? symbol x)
  (and (pair? x) (eq? (car x) symbol)))

(define gensym-counter 0)

(define (gensym)
  (set! gensym-counter (+ gensym-counter 1))
  (string->symbol (string-append ":G" (number->string gensym-counter))))

(define (foldr f z xs)
  (if (eq? '() xs)
      z
      (f (car xs) (foldr f z (cdr xs)))))


(define (assert ok? plaint culprit)
  (if (not ok?)
      (error plaint culprit)
      'fuck-off-mzscheme))

(define (should= x expected)
  (assert (equal? x expected) "Expected" expected))

(should= (elaborate '42)
         ''42)
(should= (elaborate '#f)
         ''#f)
(should= (elaborate ''())
         ''())
(should= (elaborate '(begin (write x) (lambda (y) (+ x y))))
         '((lambda (v thunk) (thunk))
           (write x)
           (lambda () (lambda (y) (+ x y)))))
(should= (elaborate '(begin (if x y z)))
         '((%true? x) (lambda () y) (lambda () z)))
(should= (elaborate '(lambda ()
                       (local ((define (for-each f xs)
                                 (if (null? xs)
                                     '()
                                     (begin (f (car xs))
                                            (for-each f (cdr xs))))))
                         for-each)))
         '(lambda ()
            (letrec ((for-each
                      (lambda (f xs)
                        ((%true? (null? xs))
                         (lambda () '())
                         (lambda ()
                           ((lambda (v thunk) (thunk))
                            (f (car xs))
                            (lambda () (for-each f (cdr xs)))))))))
              for-each)))
